[ { "title": "Akka 기초 1-6 | 액터 라이프 사이클", "url": "/posts/Akka1.6/", "categories": "Akka", "tags": "Akka", "date": "2022-05-02 01:00:00 +0900", "snippet": "Akka 기초 1-6 | 액터 라이프 사이클액터 라이프 사이클이란? 액터가 생성되고 시작된 다음 대부분의 삶을 메시지를 받는 데 보낸다. 액터가 더 이상 필요하지 않은 경우 액터를 종료하거나 “중지”할 수 있습니다.액터 라이프 사이클Akka.NET에는 액터 수명 주기의 5단계가 있다. Starting Receiving Stopping Termiated or RestartingStarting 액터가 ActorSystem에 의해 초기화 될 때의 초기 상태이다.Receving 이제 액터는 메세지를 처리 할 수 있다. Mailbox는 처리를 위해 액터의 OnReceive 메소드로 메세지를 전달하기 시작한다.Stopping 이 단계에서 일어나는 일은 액터를 종료할지, 다시 시작할지 여부에 따라 다르다. 액터가 다시 시작될 예정이라면, 액터가 다시 시작된 후 Receiving 상태로 돌아오면 처리 할 상태 또는 메세지를 이 단계 동안 저장하는 것이 일반적이다. 액터가 종료될 예정이라면, Mailbox의 모든 메세지가 ActorSystem의 DeadLetters 메일함으로 전송된다. DeadLetters는 보통 액터가 소멸되었기 때문에 배달 할 수 없는 메세지의 저장소입니다. Terminated 액터가 소멸되었다. IActorRef를 통해 전송 된 모든 메세지는 이제 DeadLetters로 이동한다. 액터는 다시 시작할 수 없지만 같은 주소를 가진 새로운 액터를 생성 할 수 있다.(IActorRef가 다르지만 ActorPath가 같음)Restarting 액터가 다시 시작되고 Starting 상태로 돌아간다.라이프 사이클 후크 메소드그렇다면, 어떻게 액터 라이프 사이클에 연결할 수 있을까? 연결할 수 있는 4개의 메소드가 있다.PreStart 액터가 메세지 수신을 시작하기 전에 PreStart 로직이 실행된다. 초기화 로직을 배치하는것 것이 좋다. 다시 시작하는 동안에도 호출된다.PreRestart 액터가 실패하면(예 : 처리되지 않은 예외 발생) 부모 액터가 액터를 다시 시작한다. PreRestart는 액터가 다시 시작되기 전에 정리를 수행하거나 나중에 재 처리하기 위해 현재 메세지를 저장하기 위해 연결할 수 있는 메소드이다.PostStop PostStop은 액터가 중지되고 더 이상 메세지를 수신하지 않으면 호출된다. 정리 로직을 포함하기에 좋은 곳이다. PostStop은 PreRestart중에도 호출되지만, 재시작 중에 이 동작을 피하려면 PreRestart를 재정의해서 base.PreRestart를 호출하지 않아도 된다. DeadWatch는 액터가 구독이 종료되면 알림을 받도록 구독 한 다른 액터에게 알릴 때도 사용된다. DeadWatch는 모든 액터가 다른 액터의 종료에 대해 알림을 받을 수 있도록 프레임 워크에 내장 된 게시/구독 시스템이다.PostRestart PostRestart는 PreRestart 후 재시작 중 PreStart 이전에 호출된다. Akka.NET이 이미 수행한 작업을 넘어서 액터 충돌을 유발한 오류에 대한 추가보고 또는 진단을 수행할 수 있는 메소드이다.다음은 후크 메소드가 라이프 사이클 단계에 적합한 위치입니다.라이프 사이클을 어떻게 후킹하나요?후킹하려면, 다음과 같이 후킹하려는 메서드를 재정의하면 된다. /// &lt;summary&gt;/// Initialization logic for actor/// &lt;/summary&gt;protected override void PreStart(){ // do whatever you need to here}가장 일반적으로 사용되는 라이프 사이클 메소드는 무엇인가요?PreStart PreStart는 가장 많이 사용되는 후크 메소드이다. 액터의 초기 상태를 설정하고 액터에 필요한 사용자 지정 초기화 로직을 실행하는데 사용된다.PostStop 사용자 지정 정리 논리를 수행하는 PostStop이다. 예를 들어, 액터가 종료하기 전에 파일 시스템 핸들이나 시스템에서 소비하고 있는 다른 리소스를 해제하도록 할 수 있다.PreRestart PreRestart는 위의 메소드보다 1/3정도 떨어지지만 가끔 사용한다. PreRestart를 사용하는 것은 액터가 하는 일에 크게 의존하지만, 한 가지 일반적인 경우는 메세지를 숨기거나 액터가 다시 시작되면 재 처리를 하기 위한 조취를 취하는 것이다.감시와 관련이 있나요? 액터가 실수로 충돌하는 경우(처리되지 않은 예외가 발생하는 경우) 액터의 감시자는 액터의 사서함에 남아 있는 메세지를 잃지 않고 액터의 수명 주기를 처음부터 자동으로 다시 시작한다. 레슨 4에서 액터 계층/감독에 대해 언급했듯이 처리되지 않은 오류에 대한 동작은 부모 액터의 SupervisionDirective에 의해 결정된다. 부모 액터는 자식 액터에게 오류에 대해 종료, 다시 시작 또는 무시하도록 지시하고 중단 된 부분부터 다시 시작할 수 있다. 기본값은 다시 시작하는 것이므로 잘못된 상태가 사라지고 액터가 깨끗하게 시작된다.실습참조Akka Bootcamp 1-6" }, { "title": "Akka 기초 1-5 | ActorSelection과 함께 주소로 액터 찾기", "url": "/posts/Akka1.5/", "categories": "Akka", "tags": "Akka", "date": "2022-05-02 01:00:00 +0900", "snippet": "Akka 기초 1-5 | ActorSelection과 함께 주소로 액터 찾기ActorSelection이란? ActorSelection은 IActorRef를 저장해 두지 않은 상태에서 액터에 메세지를 보낼 수 있도록 액터의 handle을 찾기 위해 액터 주소를 이용한 것이다. 액터가 알고 있는 IActorRef를 통해 액터를 생성하거나 소멸시키는 작업을 하는 대신, ActorPath를 통해 액터의 handle을 찾아서 할 수 있다. ActorSelection이 IActorRef를 찾는 방식이지만, 본질적으로 단일 액터를 1대1로 찾는 것은 아니라는 점을 유념해야 한다. 기술적으로, 조회할 때 표시되는 ActorSelection 객체는 특정 IActorRef를 가르키지 않는다. 검색한 표현식과 일치하는 모든 IActorRef를 가르키는 handle이다. 이 표현식에서는 와일드 카드가 지원되므로 0개 이상의 액터가 선택될 수 있다. ActorSelection에 의해 이름이 같은 첫번째 액터가 소멸된 후 같은 이름으로 다시 생성한 서로 다른 두 IActorRef가 매칭될 수 있다.오브젝트(object) 인가요? 프로세스(process)? 둘다? ActorSelection이 프로세스와 오브젝트 둘 모두라고 생각한다. ActorPath로 액터를 찾는 프로세스와 그 과정에서 되돌아온 오브젝트는 우리가 찾던 표현과 일치하는 액터에게 메세지를 보낼 수 있게 해준다.왜 ActorSelection에 대해 신경써야 하나요? 일반적으로 항상 IActorRef를 대신 사용해야 한다. 그러나 ActorSelection이 작업에 적합한 도구인 몇가지 시나리오가 있으며 여기에서 더 자세히 다룬다.동적 행동 동적 행동은 Unit2 초반에 파고드는 상급개념이지만, 지금은 주어진 액터의 행동이 매우 유연할 수 있다는 것만 알아두면 된다. 이를 통해 액터는 유한 상태 기계와 같은 것을 쉽게 표현하여 작은 코드 설치 공간으로 복잡한 상황을 쉽게 처리할 수 있다. ActorSelection은 어디에서 활약할까요? 당신이 매우 역동적이고 적응력이 뛰어난 시스템을 원한다면, 아마도 많은 액터가 계층 구조에서 들어오고 나가는 가운데 그 모두에게 핸들을 저장/전달 하는 것은 정말 고통스러울 것이다. ActorSelection을 사용하면 통신해야 하는 키 액터의 잘 알려진 주소로 메세지를 쉽게 보낼 수 있고, 필요한 항목에 대한 핸들을 가져오거나 전달, 저장하는 것에 대해 걱정할 필요가 없다. 또한, ActorSelection을 수행하는데 필요한 ActorPath 조차 하드 코딩되지 않는 대신에 액터에 전달되는 메세지로 대표 될 수 있는 극도로 동적인 액터를 빌드할 수 있다.주의 : ActorSelection을 전달하지 마십시오. IActorRef처럼 ActorSelection을 매개 변수로 전달하지 않는 것을 권한다. ActorSelection이 절대적이 아니라 상대적 일 수 있기 때문인데, 이 경우 계층 구조에서 다른 위치를 가진 액터에 전달 될 때 의도한 효과를 내지 못한다.ActorSelection은 어떻게 만드나요? ActorSelection을 만드는 것은 매우 간단하다.var selection = Context.ActorSelection(\"/path/to/actorName\"); NOTE : 액터 경로에는 액터 클래스명이 아닌 액터를 인스턴스화 할 때 액터에 할당한 이름을 사용한다.액터를 만들 때 이름을 지정하지 않으면 시스템에서 고유한 이름을 자동으로 생성한다.예제 :class FooActor : UntypedActor {}Props props = Props.Create&lt;FooActor&gt;();IActorRef myFooActor = MyActorSystem.ActorOf(props, \"barBazActor\");IActorRef myFooActor = MyActorSystem.ActorOf(props);ActorSelection과 IActorRef에 다르게 메세지를 보내나요? ActorSelection도 IActorRef와 똑같이 메세지를 보낼 때 Tell()을 사용한다. var selection = Context.ActorSelection(\"/path/to/actorName\");selection.Tell(message); 실습참조Akka Bootcamp 1-5" }, { "title": "LINQ to Objects의 기초", "url": "/posts/CSharp-LINQ/", "categories": "LINQ", "tags": "LINQ", "date": "2022-04-20 01:00:00 +0900", "snippet": "LINQ to Objects의 기초LINQ란 “Language Integrated Quer”를 축약한 것이며 한국어로는 ‘언어로 통합된 쿼리’라고 말할 수 있다.LINQ를 사용하면 객체, 데이터, XML과 같은 다양한 데이터를 표준화된 방법으로 처리할 수 있다.LINQ to Objects의 간단한 예var names = new List&lt;string&gt;{ \"Seoul\", \"New Delhi\", \"Bangkok\", \"London\", \"Paris\", \"Berlin\", \"Canberra\", \"Hong Kong\"};IEnumerable&lt;string&gt; query = names.Where(s =&gt; s.Length &lt;= 5);foreach(string s in query) Console.WriteLine(s); FindAll 메서드와 다른점 IEnumerable 인터페이스를 구현하는 형이기만 하면 `Where` 메서드를 해당 객체를 대상으로 이용할 수 있다 Where 메서드의 반환값이 IEnumerable이다. 따라서 메서드 체인이 가능하다. LINQ 지연 실행string[] names = {\"Seoul\", \"New Delhi\", \"Bangkok\", \"London\", \"Paris\", \"Berlin\", \"Canberra\", };var query = names.Where(s =&gt; s.Length &lt;= 5);foreach(var item in query) Console.WriteLine(item);Console.WriteLine(\"-------\");names[0] = \"Busan\";foreach(var item in query) Console.WriteLine(item); where 메서드의 반환값을 query 변수에 대입 한 후에 names 배열의 요소를 수정했다. 이 코드를 실행한 결과는 다음과 같다SeoulParis-------BusanParis 이 query 변수에는 검색된 결과가 대입되는 것이 아니다. 다시 말해 Where 메서드가 호출돼도 검색은 해당 시점에서 실행되지 않고 실제 값이 필요할 때 쿼리가 실행된다는 것을 나타낸다. 이를 지연 실행이라고 한다. 실제로 데이터가 필요할 때 쿼리가 실행된다. 이것이 LINQ의 큰 특징이다.그러나 경우에 따라서는 쿼리를 명시적으로 실행하고 싶을 때도 있을 것이다. 그럴 때 이용할 수 있는 것이 ToArray와 ToList 메서드다.string[] names = {\"Seoul\", \"New Delhi\", \"Bangkok\", \"London\", \"Paris\", \"Berlin\", \"Canberra\", };var query = names.Where(s =&gt; s.Length &lt;= 5).ToArray(); // 여기서 배열로 변환한다.foreach(var item in query) Console.WriteLine(item);Console.WriteLine(\"-------\");names[0] = \"Busan\";foreach(var item in query) Console.WriteLine(item); 이렇게 하면 ToArray 메서드가 호출됐을 때 쿼리가 실행되며 그 결과가 배열에 저장된다. 이를 즉시 실행이라고 한다. LINQ에는 ToArray 메서드나 ToList 메서드 외에도 즉시 실행되는 메서드가 있다. Count 메서드가 그중 하나다.string[] names = {\"Seoul\", \"New Delhi\", \"Bangkok\", \"London\", \"Paris\", \"Berlin\", \"Canberra\", };var count = names.Count(s =&gt; s.Length &gt; 5); // 여기서 배열로 변환한다.Console.WriteLine(count); 위의 예에서는 names 안에 문자열의 길이가 5보다 큰 문자열이 몇 개 있는지 세어 그 결과를 반환한다. LINQ에는 Count 메서드처럼 하나의 값을 반환하는 메서드가 있는데 이런 메서드는 모두 즉시 실행되는 메서드다." }, { "title": "Akka 기초 1-4 | 자식 액터, 액터 계층 구조, 그리고 감시(Supervision)", "url": "/posts/Akka1.4/", "categories": "Akka", "tags": "Akka", "date": "2022-04-20 01:00:00 +0900", "snippet": "Akka 기초 1-4 | 자식 액터, 액터 계층 구조, 그리고 감시(Supervision)계층 구조의 원자화 작업계층 구조를 가지는 것은 아주 작은 조각으로 작업을 쪼개고, 서로 다른 계층의 레벨에서 다른 전문 기술을 활용할 수 있게 한다. 액터 시스템에서 이것이 실현되는 일반적인 방법은 큰 데이터 스트림을 원자화하는 것이다. 트위터를 예로 들자면 Akka를 사용하면 대용량 데이터 수집을 작고, 처리하기 쉬운 정보의 흐름으로 분해할 수 있다. 트위터의 경우 거대한 소방호스를 통해 뿜어져 나오는 것 같은 트윗들을 각 유저들의 타임라인에 작은 물줄기 하나한로 나누어 분산할 수 있다. Akka를 사용하여 해당 유저의 스트림으로 도착한 메세지를 websoket 등을 통해 푸시할 수도 있다. 계층 구조를 통해 복원력 있는 시스템 자원 상위 계층의 액터는 본질적으로 좀 더 감독적(supervisional)이며, 이러한 점은 액터 시스템의 리스크를 낮춘다. 계층의 가장자리로 위험한 작업을 밀어냄으로써 시스템은 리스크를 고립시키고 전체 시스템의 크래싱 없이 오류로부터 복구할 수 있다.감시(Supervision)란? 왜 신경써야 하나? 감시(Supervision)는 액터 시스템이 오류에서 빠르고 신속하게 격리와 회복이 이뤄질 수 있게 하는 기본 개념이다. 모든 액터는 자신을 감시하는 다른 액터를 가지고 있으며, 이 액터들은 에러가 발생했을 때 복구할 수 있도록 돕는다. 감시는 애플리케이션이 예기치 않은 오류가 발생할 경우, 액터 계층 구조에서 해당 계층에만 영향을 받도록 제어한다.액터의 계층 구조 모든 액터는 부모 액터를 가지고 있다. 그리고 일부 액터들은 자식을 가지고 있다. 부모 액터는 자식을 감독한다. 부모 액터가 자식 액터를 감독한다는 것은 모든 액터가 감독자를 가진다는 것이고, 모든 액터가 감독자가 될 수 있음을 말한다. 액터 시스템 내에서 액터는 계층 구조로 정리된다. ActorSystem 자체에 직접 보고하는 “최상위” 액터와 다른 액터에게 보고하는 “자식” 액터가 있음을 의미한다. 전반적인 계층 구조는 다음과 같다.계층 구조의 레벨이란? “Guardians”는 전체 시스템의 root 액터입니다. 계층 구조에서 최상단에 있는 3개의 액터를 말한다./ 액터/ 액터는 액터 시스템 전체의 root 액터입니다. “The Root Guardian” 이라고 불립니다. 이 액터는 다른 “Guardians” (/system과 /user 액터)을 감독한다. 이 하나를 제외한 모든 액터는 그들의 부모 액터를 필요로 한다. 이 액터는 일반 액터 시스템의 바깥(“out of the bubble”)에 있기 때문에 때때로 “bubble-walker”라고 불린다./system액터/system 액터는 “시스템 가디언”이라고 불린다. 이 액터의 주 역할은 정상적인 방법으로 시스템이 종료되고, 프레임워크 레벨의 기능 및 유틸리티로 구현된 다른 시스템 액터를 유지하고 감독한다./user 액터/user액터는 “가디언 액터”로 불린다. 사용자 관점에서 볼 때 /user 액터는 시스템의 root이기 때문에 “root actor” 라고 부른다. 일반적으로 “root actor”는 user액터를 말한다.사용자는 가디언에 대해 걱정할 필요가 없다. 어떠한 예외도 가디언까지 거품을 일으켜 전체 시스템에 크래시가 발생하지 않도록 /user 아래에서 적절하게 감독된다./user 액터의 계층 구조액터 계층 구조의 주요 포인트이다. 애플리케이션 내에서 당신이 정의한 모든 액터들이 속한다. /user 액터 바로 아래의 자식 액터를 “최상위 액터(top level actors)”라고 부른다. 액터는 항상 다른 액터의 자식 액터로 만들어진다. 액터 시스템 자체의 커텍스트를 활용해 직접 액터를 만들면, 새 액터는 최상위 액터가 된다.// 다이어그램에 표현된 최상위 액터를 만듭니다.IActorRef a1 = MyActorSystem.ActorOf(Props.Create&lt;BasicActor&gt;(), \"a1\");IActorRef a2 = MyActorSystem.ActorOf(Props.Create&lt;BasicActor&gt;(), \"a2\");a2 컨텍스트 안쪽에서 a2의 자식 액터들을 만들어 보자.// a2의 자식 액터들을 만듭니다.// a2의 내부에서 진행합니다.IActorRef b1 = Context.ActorOf(Props.Create&lt;BasicActor&gt;(), \"b1\");IActorRef b2 = Context.ActorOf(Props.Create&lt;BasicActor&gt;(), \"b2\");액터 주소(Actor Path) == 계층 구조 내에서 액터의 위치 모든 액터는 주소를 가진다. 액터에서 다른 액터로 메세지를 보내려면 주소를 알아야 한다. 액터 주소는 다음과 같다. “Path”는 액터가 당신의 액터 계층 구조에서 어디에 위치하는지 알려준다. 슬래시(‘/’)로 액터의 계층을 구분한다.만일 localhost에서 실행했다면, b2 액터의 완전한 주소는 akka.tcp://MyActorSystem@localhost:9001/user/a2/b2입니다. 내가 만든 FooActor 액터 클래스를 BarActor의 자식 액터로만 배포할 수 있을까요? 아니면 어디든 가능할까요? 이에 대한 대답은 어떤 액터든 당신의 액터 계층 구조 안에서 어디에나 위치할 수 있다 액터 계층 구조에서 감시가 동작하는 방법 액터는 자식 액터를 감독한다. 하지만, 그들은 액터 계층 구조에서 바로 아래 단계만 감독한다.(액터는 손자, 증손자 등을 감독하지 않는다.) 액터는 계층 구조상 바로 아래 단계의 자식만 감독한다. 언제 감시가 시작되나요? 에러가 발생하면! 자식 액터가 unhandled exception이나 클래시가 발생할 때, 부모 액터에게 도움을 청하고 무엇을 해야하는지 알려준다. 구체적으로, 자식 액터는 Failure 클래스의 메세지를 부모 액터에게 보낸다. 무엇을 해야할지 결정하는 것은 부모액터에게 달려있다.부모 액터는 어떻게 오류를 해결할 수 있을까?오류 해결 방법을 결정하는 두 가지 요소가 있다. 자식 액터의 실패 요인(자식 액터가 보낸 Failure 메세지에 어떤 타입의 Exception이 포함되었는가) 자식 액터의 Failure에 대한 부모 액터가 실행하는 명령. 이는 부모 액터의 감시 전략(SupervisionStrategy)에 의해 결정된다. 오류가 발생했을 때 이벤트의 순서 자식 액터(c1)에서 Unhandled Exception이 발생하면, 부모 액터(b1)에 의해 관리 된다. c1은 작업을 중지한다. 시스템은 Failure 메세지에 Exception을 담아 c1에서 b1으로 전달한다. b1은 c1에게 어떻게 해야하는지 지시한다. 감시 지침(Supervision directives) 자식 액터에게서 에러를 받으면, 부모 액터는 다음 동작 중 하나를 수행 할 수 있다.(지침, 감시 전략)은 예외 타입에 따라 침을 매핑하므로, 여러 에러의 유형에 따라 적절하게 처리 할 수 있다. 감시 지침의 종류(감독자가 할 수 있는 결정) : Restart the child (default) : 가장 일반적인 경우이며 기본값이다. Stop the child : 자식 액터를 영구히 종료한다. Escalate the error(and stop itself) : 이건 부모 액터가 “뭘 해야 할지 모르겠어! 다 멈추고 ‘내’ 부모 액터에게 물어봐야겠어!” 라고 말하는 거다. Resume processing (ignores the error) : 일반적으로는 사용하지 않는다. 일단 무시하자. 여기서 알아야 할 중요한 것은 부모 액터에게 어떤 조치가 취해지든 자식 액터에게 전파된다는 것이다. 부모 액터가 중단되면 모든 자식 액터가 중단된다. 다시 시작하면 모든 자식 액터가 다시 시작된다. 감독 전략(Supervision strategies) 두 가지 기본 감독 전략이 있다. One-For-One Strategy (default) All-For-One Strategy 두 가지의 기본적인 차이점은 에러 해결 지시 효과가 얼마나 널리 퍼지는지이다. One-For-One 부모의 지시가 실패한 자식 액터에게만 적용된다. 실패한 자식의 형제 자매에게 영향을 끼치지 않는다. 이것은 특별히 지정하지 않는 이상 기본값으로 동작한다.(또한 커스텀 감독 전략을 정의할 수도 있다.) All-For-One 부모의 지시가 실패한 자식과 실패한 자식의 모든 형제 자매에게 적용된다. 감독 전략에서 또 다른 중요한 선택은, 자식이 얼마의 시간 동안에 몇 번의 실패를 허용하는가 이다. 핵심은 Containment 감독 전략과 지시의 전체적인 핵심은 시스템 내에서 오류를 포함하고 자가 치유하는 것이므로, 시스템 전체에 클래시가 발생하지 않는 것이다. 우리는 잠재적으로 위험한 작업을 부모에서 자식에게 전달한다. 이 작업은 위험한 작업을 수행하는 것이다. 예를 들어, 스코어 키퍼는 게임이 진행되는 동안 정기적으로 데이터를 업데이트해야 한다. FIFA가 관리하는 외부 API를 호출해서 필요한 데이터를 가져온다고 가정하자 만약 요청이 오류를 발생시키면, 호출을 시작한 액터는 크래시가 발생한다. 그러면 어떻게 보호해야 하는가? 부모 액터가 상태를 보관하고, 형편없는 네트워크 호출은 자식 액터에게 밀어 넣는다. 자식 액터가 크래시 나더라도, 중요한 데이터를 보관하고 있는 부모에게 영향을 끼치지 않는다. 오류를 지역화(localizing the failure) 하여 시스템 전체에 퍼지는 것을 방지한다. 이러한 구조를 게임당 하나씩 만들어 병렬로 처리할 수 있다는 점을 상기해라. 새로운 코드를 작성할 필요가 없다!실습참조Akka Bootcamp 1-4" }, { "title": "xUnit.net 시작하기", "url": "/posts/.NET-xUnit/", "categories": "xUnit", "tags": "xUnit", "date": "2022-04-20 01:00:00 +0900", "snippet": "xUnit.net 시작하기단위 테스트 프로젝트 만들기 xUnit 테스트 프로젝트를 만든다.프로젝트 파일 구조&lt;Project Sdk=\"Microsoft.NET.Sdk\"&gt; &lt;PropertyGroup&gt; &lt;TargetFramework&gt;net6.0&lt;/TargetFramework&gt; &lt;Nullable&gt;enable&lt;/Nullable&gt; &lt;IsPackable&gt;false&lt;/IsPackable&gt; &lt;/PropertyGroup&gt; &lt;ItemGroup&gt; &lt;PackageReference Include=\"Microsoft.NET.Test.Sdk\" Version=\"16.11.0\" /&gt; &lt;PackageReference Include=\"xunit\" Version=\"2.4.1\" /&gt; &lt;PackageReference Include=\"xunit.runner.visualstudio\" Version=\"2.4.3\"&gt; &lt;IncludeAssets&gt;runtime; build; native; contentfiles; analyzers; buildtransitive&lt;/IncludeAssets&gt; &lt;PrivateAssets&gt;all&lt;/PrivateAssets&gt; &lt;/PackageReference&gt; &lt;PackageReference Include=\"coverlet.collector\" Version=\"3.1.0\"&gt; &lt;IncludeAssets&gt;runtime; build; native; contentfiles; analyzers; buildtransitive&lt;/IncludeAssets&gt; &lt;PrivateAssets&gt;all&lt;/PrivateAssets&gt; &lt;/PackageReference&gt; &lt;/ItemGroup&gt;&lt;/Project&gt; TargetFramework : 테스트 프로젝트의 대상 프레임워크를 지정한다. &lt;TargetFramework&gt;net6.0; net5.0&lt;/TargetFramework&gt; 다음과 같이 입력 시 여러 대상 프레임워크에 대한 테스트 실행이 가능하다. 첫 번째 Test 작성 다음과 같이 테스트 코드를 작성한다. 통과 테스트와 실패 테스를 모두 작성했으며 결과에 이를 반영하는 것을 볼 수 있다.using Xunit;namespace MyFirstUnitTests{ public class UnitTest1 { [Fact] public void PassingTest() { Assert.Equal(4, Add(2, 2)); } [Fact] public void FailingTest() { Assert.Equal(5, Add(2, 2)); } int Add(int x, int y) { return x + y; } }} 솔루션 탐색기의 테스트 실행 버튼을 눌러 테스트를 진행한다. 테스트 탐색기를 통해 결과, 테스트 소스에 대한 링크, 예외 메시지 등을 확인할 수 있다. 첫 번째 Theory 작성xUnit.net은 Fact와 Theory라는 두 가지 주요 단위 테스트 유형에 대한 지원을 한다. Fact와 Theory의 차이점 Fact : 항상 참인 테스트입니다. 불변 조건을 테스트합니다. TheoryI : 특정 데이터 세트에 대해서만 참인 테스트입니다. 예로 숫자가 홀수인지 여부를 결정하는 알고리즘을 테스트한다고 가정해보자. 홀수를 판별하는 테스트에 짝수를 입력하면 테스트가 실패할 것이며 테스트나 알고리즘이 잘못된게 아닌 데이터가 잘못되었기 때문이다. 다음과 같이 테스트 코드를 작성한다.[Theory][InlineData(3)][InlineData(5)][InlineData(6)]public void MyFirstTheory(int value){ Assert.True(IsOdd(value));}bool IsOdd(int value){ return value % 2 == 1;} 테스트 탐색기에서 실패한 데이터 세트를 확인할 수 있다.참조xUnit.net" }, { "title": "Akka 기초 1-3 | Props와 IActorRef", "url": "/posts/Akka1.3/", "categories": "Akka", "tags": "Akka", "date": "2022-04-17 22:00:00 +0900", "snippet": "Akka 기초 1-3 | Props와 IActorRefIAcotrRef 무엇인가요? IActorRef는 액터에 대한 참조(reference) 또는 핸들(handle) IActorRef의 목적은 ActorSystem을 통해 액터에게 메시지를 전송하는 것을 지원내 액터와 실제로 대화하지 않아요? 왜 안돼요? IAcotrRef로 메시지를 보내고, ActorSystem이 실제 액터에게 메세지를 전달하는 것이 좋은 이유 ActorSystem은 모든 메세지를 각 메세지에 대한 메타 데이터를 포함하여 Envelope로 포장 위치 투명성을 허용한다. ※ 위치 투명성 : 액터가 어느 프로세스나 머신에 올라와 있는지 상관 X그래서 IActorRef는 어떻게 얻을 수 있나요?IActorRef를 얻는 두 가지 방법 액터 생성// \"MyActorSystem\" 이라는 액터 시스템을 가지고 있다고 가정 합니다.IActorRef myFirstActor = MyActorSystem.ActorOf(Props.Create(() =&gt; new MyActorClass()), \"myfirstActor\"); 위의 예제에서 볼 수 있듯이, 항상 감독할 액터의 컨텍스트에서 엑터를 만든다. 위와 같이 ActorSystem 위에서 직접 액터를 만들면 최상위 액터가 된다.다음과 같이 다른 액터에서 만드는 것을 제외하면 자식 엑터 또한 똑같은 방법으로 만든다.// MyActorClass 내부에서 child actor를 만들어야 할 때도 있습니다.// 보편적으로 OnReceive 나 PreStart 안에서 일어납니다.class MyActorClass : UntypedActor{ protected override void Prestart() { IActorRef myFirstChildActor = Context.ActorOf(Props.Create(() =&gt; new MyChildActorClass()), \"myFirstChildActor\"); }}주의 : 액터를 만들기 위해 Props와 ActorSystem의 외부에서 new MyActorClass()를 호출하지 마십시오. ActorSystem의 컨텍스트 외부에서 액터를 만든다면 바람직하지 못한 오브젝트가 만들어집니다. 액터 찾기 모든 액터는 시스템 계층 속에서 어디에 있는지를 나타내는 기술적인 (ActorPath라는 이름의) 주로를 가지고 있다. 주소로 액터를 찾아서 (IActorRef를 입수하여) 핸들을 얻을 수도 있다.액터들에게 꼭 이름을 지어야 하나요? 이름은 필수가 아니다. 액터 이름은 로그 메세지와 액터의 식별에 사용되기 때문에 이름을 지어주는것이 좋다.// ActorOf()를 호출할 때의 마지막 Argument가 이름입니다.IActorRef myFirstActor = MyActorSystem.ActorOf(Props.Create(() =&gt; new MyActorClass()), \"myFirstActor\");// ActorIf() 항수를 호출할 때, 마지막 argument로 이름을 주지 않았습니다.IActorRef myFirstActor = MyActorSystem.ActorOf(Props.Create(() =&gt; new MyActorClass()));컨텍스트(Context)는 어디에 사용되나요? 모든 액터들은 컨텍스트가 존재하며, 모든 액터들에 내장된 Context 속성으로 접근할 수 있다. Context에는 현재 메세지의 Sender, 현재 액터의 Parent, Children과 같은 액터의 현재 상태에 관련된 메타 데이터가 있다. Parent, Children, 그리고 Sender 모두 IActorRef를 제공하고 사용할 수 있다.Props란?Props는 액터를 만들기 위한 레시피로 생각하면 된다. 전문적으로 Props는 주어진 액터 타입의 인스턴스를 만들기 위해 필요한 정보를 캡슐화하는 configuration class이다.왜 Props가 필요합니까? Props 오브젝트는 액터의 인스턴스를 생성하는 것에 사용하는 공유 가능한 레시피이다. Props는 ActorSystem으로 전달되어 당신이 사용할 액터를 생성한다. Props는 원격 작업을 수행하는데 필요한 배포 정보와 다른 세부적인 설정을 포함하도록 확장된다. 예를 들어, Props는 직렬화 할 수 있으므로, 네트워크 어딘가의 다른 머신에서 전체 액터 그룹을 원격으로 생성하고 배포할 수 있다. Props를 어떻게 만들 수 있나요?주의 : Props를 만들기 위해 new Props(...)를 호출하지 마십시오. 액터를 만들기 위해 new MyActorClass() 를 호출하는 것처럼 이것은 프레임워크와 싸우고 Akka의 ActorSystem에게 재시작, 라이프사이클 관리와 관련한 안전보장 제공을 시키지 못합니다.Props를 만드는 3가지 방법은 아래와 같으며, 전부 Props.Create() 호출을 포함한다. typeof문법Props props1 = Props.Create(typeof(MyActor)); 단순해 보이지만, 추천하지 않는다. 타입 안정성이 없으며, 컴파일을 통과하고 런타임에 터트리는 버그를 쉽게 만들게 한다. lambda 문법Props props2 = Props.Create(() =&gt; new MyActor(...), \"...\"); generic 문법Props props3 = Props.Create&lt;MyActor&gt;();Props는 어떻게 사용하나요? Props- 액터 레시피를 Context.ActorOF() 호출에 전달하고, ActorSystem은 이 레시피를 읽는다.실습참조Akka Bootcamp 1-3" }, { "title": "Akka 기초 1-2 | 메시지 정의 및 핸들링", "url": "/posts/Akka1.2/", "categories": "Akka", "tags": "Akka", "date": "2022-04-17 22:00:00 +0900", "snippet": "Akka 기초 1-2 | 메시지 정의 및 핸들링메세지(message) 란? 메세지는 string, int와 같은 value, 인터페이스를 구현하는 오브젝트 등 모두 가능액터(Actor)에게 메세지를 보내려면 어떻게 하죠? Tell()을 이용내 액터가 처리하는 법을 모르는 메세지를 받으면 어떻게 되죠? 액터는 처리하는 법을 모르는 메세지는 무시 무시된 메세지는 액터의 종류에 따라 로깅도 함 UntypedActor에서는, 처리되지 않은 메세지를 수동으로 Unhandled()하지 않는 이상 로깅 되지 않음 ReceiveActor에서는 처리되지 않은 메세지는 자동으로 Unhandled로 보내고 로깅 수행실습참조Akka Bootcamp 1-2" }, { "title": "Akka 기초 1-1 | 액터와 액터시스템(ActorSystem)", "url": "/posts/Akka1.1/", "categories": "Akka", "tags": "Akka", "date": "2022-04-17 22:00:00 +0900", "snippet": "Akka 기초 1-1 | 액터와 액터시스템(ActorSystem)액터(actor) 란? 그것은 일을하고 의사 소통 할 수 있는 독립체(entity), 객체(object) OOP(객체 지향 프로그래밍)에서 모든 것이 객체 인 것처럼 액터 모델에서는 모든 것이 액터액터가 할 수 있는 일은? 액터를 자신에게 수신된 메세지를 처리하도록 작성하면, 액터는 메세지 처리에 따라 뭐든지 가능 다른 앹거 생성 다른 액터에게 메세지 전송 자신의 동작을 변경하여 다음 수신 메세지를 다른 방식으로 처리어떤 종류의 액터가 있는가? 모든 형태의 액터는 UntypedActor를 상속받음액터는 어떻게 만들죠? 모든 액터들은 관련된 context 내에서 생성 액터를 만들기 위해 Props가 필요 Props 객체는 단지 주어진 종류의 액터를 만들기 위한 공식을 캡슐화한 객체액터시스템(ActorSystem)이 뭐죠? ActorSystem은 Underlying System과 Akka.NET 프레임워크에 대한 참조 모든 액터들은 액터 시스템의 context 내에서 동작실습참조Akka Bootcamp 1-1" }, { "title": "람다식이란?", "url": "/posts/CSharp-Lambda/", "categories": "C#, Lambda", "tags": "C#, Lambda", "date": "2022-04-05 23:00:00 +0900", "snippet": "람다식이란?Step 0(가장 긴 코드)Predicate&lt;int&gt; judge = (int n) =&gt; { // 이 부분이 람다식 if(n % 2 == 0) // 이 부분이 람다식 return true; // 이 부분이 람다식 else // 이 부분이 람다식 return false; // 이 부분이 람다식 }; // 이 부분이 람다식var count = Count(numbers, judge); 람다식은 일종의 메서드라고 생각하면 된다. C# 2.0 시절에 있었던 delegate 키워드가 없어지고 =&gt;(람다 연산자) 가 사용된다. =&gt;의 좌변에서 인수를 선언하고 오른쪽에는 메서드의 본문을 선언한다. 이 람다식이 judge 변수에 대입되고 judge 변수가 Count 메서드의 인수에 전달된다.Step 1var count = Count(numbers, (int n) =&gt; { if(n % 2 == 0) return true; else return false; }); judge 변수를 없애고 식을 직접 Count 메서드의 인수로 지정한다. 변수의 형이 int 형이나 string 형일 때와 마찬가지이다.Step 2var count = Count(numbers, (int n) =&gt; { return n % 2 == 0; }); return의 오른쪽에 ‘n % 2 == 0’을 써 if 문을 없앨 수 있다.Step 3var count = Count(numbers, (int n) =&gt; n % 2 == 0); 람다식에서 {}가 하나의 명령문을 포함할 때는 {}와 return을 생략할 수 있다.Step 4var count = Count(numbers (n) =&gt; n % 2 == 0); 람다식에서는 인수의 형을 생략할 수 있다.Step 5var count = Count(numbers, n =&gt; n % 2 == 0); 인수가 한 개인 경우에는 ()를 생략할 수 있다. 이것이 람다식을 사용한 Count 메서드 호출의 최종적인 형태이다." } ]
